<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width">
    <title>Multiplication Asteroids</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: black;
            color: white;
            font-family: Arial, sans-serif;
        }
        #gameCanvas {
            display: block;
            background-color: black;
        }
        #score {
            position: absolute;
            top: 10px;
            left: 10px;
            font-size: 24px;
            z-index: 1;
        }
        #currentAnswer {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 24px;
            z-index: 1;
        }
        #gameOver {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2;
        }

        #gameOver h1 {
            color: red;
            font-size: 60px;
            margin-bottom: 30px;
        }

        #scoreInfo {
            color: white;
            font-size: 24px;
            margin-bottom: 30px;
            text-align: center;
        }

        #playAgainButton {
            font-size: 24px;
            padding: 15px 30px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        #playAgainButton:hover {
            background-color: #45a049;
        }

        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }

        #startScreen h1 {
            color: white;
            font-size: 36px;
            margin-bottom: 20px;
        }

        #startButton {
            font-size: 24px;
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        #startButton:hover {
            background-color: #45a049;
        }

        #highScore, #startScreen div ol {
            color: white;
            font-size: 20px;
            text-align: center;
            margin-top: 20px;
        }

        #highScore h2, #startScreen div h2 {
            margin-bottom: 10px;
            color: #FFD700; /* Gold color for emphasis */
        }

        #highScore ol, #startScreen div ol {
            padding-left: 20px;
        }

        #highScore li, #startScreen div li {
            margin-bottom: 5px;
        }

        /* **New: Styles for Feedback Message** */
        #feedback {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: red;
            font-size: 36px;
            font-weight: bold;
            display: none; /* Hidden by default */
            z-index: 3;
        }

        /* Animation for fading out the feedback */
        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        .fade-out {
            animation: fadeOut 1s forwards;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="score">Score: 0</div>
    <div id="currentAnswer"></div>
    <div id="gameOver">
        <h1>Game Over</h1>
        <div id="scoreInfo">
            <p id="finalScore"></p>
            <p id="highScore"></p>
        </div>
        <button id="playAgainButton">Play Again</button>
    </div>
    
    <div id="startScreen">
        <h1>Multiplication Asteroids</h1>
        <button id="startButton">Start Game</button>
    </div>

    <!-- **New Feedback Element** -->
    <div id="feedback"></div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreElement = document.getElementById('score');
        const currentAnswerElement = document.getElementById('currentAnswer');
        const gameOverElement = document.getElementById('gameOver');
        const startScreen = document.getElementById('startScreen');
        const startButton = document.getElementById('startButton');
        const finalScoreElement = document.getElementById('finalScore');
        const playAgainButton = document.getElementById('playAgainButton');
        const highScoreElement = document.getElementById('highScore');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let score = 0;
        let currentAnswer = '';
        const bullets = [];
        const asteroids = [];
        let gameOver = false;
        let gameStarted = false;
        let highScore = 0;

        // Initialize high scores from localStorage or set to empty array
        let highScores = JSON.parse(localStorage.getItem('highScores')) || [];
        const maxHighScores = 5; // Maximum number of high scores to keep

        // **New: Initialize missed facts from localStorage or set to empty array**
        let missedFacts = JSON.parse(localStorage.getItem('missedFacts')) || [];

        // Constant to define exposure multiplier
        const MISSED_FACT_MULTIPLIER = 3;

        // Ship object
        const ship = {
            x: canvas.width / 2,
            y: canvas.height / 2,
            angle: 0, // in radians
            rotation: 0,
            velocity: { x: 0, y: 0 },
            speed: 0.2
        };

        const bulletSpeed = 7;
        const bulletRange = 300; // Limited range for bullets
        const maxAsteroidSize = 40;
        const minAsteroidSize = 15;

        // Event listeners for keyboard inputs
        const keys = {};

        window.addEventListener('keydown', function(e) {
            if (e.code === 'ArrowUp') {
                keys['ArrowUp'] = true;
            } else if (e.code === 'ArrowLeft') {
                keys['ArrowLeft'] = true;
            } else if (e.code === 'ArrowRight') {
                keys['ArrowRight'] = true;
            } else if (e.code === 'Space') {
                fireBullet();
            } else if (e.code === 'Backspace') {
                currentAnswer = currentAnswer.slice(0, -1);
            } else if (!isNaN(e.key)) {
                currentAnswer += e.key;
            }
            updateCurrentAnswerDisplay();
        });

        window.addEventListener('keyup', function(e) {
            if (e.code === 'ArrowUp') {
                keys['ArrowUp'] = false;
            } else if (e.code === 'ArrowLeft') {
                keys['ArrowLeft'] = false;
            } else if (e.code === 'ArrowRight') {
                keys['ArrowRight'] = false;
            }
        });

        function updateCurrentAnswerDisplay() {
            currentAnswerElement.textContent = `Answer: ${currentAnswer}`;
        }

        // Function to create an asteroid
        function createAsteroid(x = Math.random() * canvas.width, y = Math.random() * canvas.height, size = maxAsteroidSize) {
            let pickedFact = null;

            // **New Logic: Prioritize missed facts**
            if (missedFacts.length > 0) {
                const totalMissed = missedFacts.reduce((acc, fact) => acc + MISSED_FACT_MULTIPLIER, 0);
                const randomNum = Math.random() * (totalMissed + getTotalRandomFactors());

                if (randomNum < totalMissed) {
                    // Pick a missed fact
                    let cumulative = 0;
                    for (let fact of missedFacts) {
                        cumulative += MISSED_FACT_MULTIPLIER;
                        if (randomNum < cumulative) {
                            pickedFact = { a: fact.a, b: fact.b };
                            break;
                        }
                    }
                }
            }

            // **If no missed fact is picked, generate a random fact**
            if (!pickedFact) {
                const a = Math.floor(Math.random() * 10); // Adjust range as needed
                const b = Math.floor(Math.random() * 10);
                pickedFact = { a, b };
            }

            const { a, b } = pickedFact;
            return {
                x,
                y,
                size,
                a,
                b,
                velocity: {
                    x: (Math.random() - 0.5) * 2, // Random velocity between -1 and 1
                    y: (Math.random() - 0.5) * 2
                },
                vertices: generateAsteroidVertices(size)
            };
        }

        // **Helper Function: Calculate total weight of random factors**
        function getTotalRandomFactors() {
            // Assuming regular facts have a weight of 1 each
            // Adjust if you have a specific range
            return 10 * 10; // Example: factors a and b from 0-9
        }

        // Function to generate irregular asteroid shape
        function generateAsteroidVertices(size) {
            const vertices = [];
            const vertexCount = Math.floor(Math.random() * 5) + 5; // Between 5 and 9 vertices
            for (let i = 0; i < vertexCount; i++) {
                const angle = (Math.PI * 2 / vertexCount) * i;
                const distance = size + Math.random() * size * 0.4 - size * 0.2; // Slight variation
                vertices.push({ angle, distance });
            }
            return vertices;
        }

        // Initialize initial asteroids
        function initAsteroids() {
            asteroids.length = 0; // Clear existing asteroids
            for (let i = 0; i < 5; i++) {
                asteroids.push(createAsteroid());
            }
        }

        // Function to draw the ship
        function drawShip() {
            ctx.save();
            ctx.translate(ship.x, ship.y);
            ctx.rotate(ship.angle);
            ctx.beginPath();
            ctx.moveTo(20, 0); // Tip of the ship
            ctx.lineTo(-10, 10);
            ctx.lineTo(-10, -10);
            ctx.closePath();
            ctx.strokeStyle = 'white';
            ctx.stroke();
            ctx.restore();

            // Draw dashed firing line
            ctx.save();
            ctx.translate(ship.x, ship.y);
            ctx.rotate(ship.angle);
            ctx.setLineDash([10, 10]);
            ctx.strokeStyle = 'white';
            ctx.beginPath();
            ctx.moveTo(20, 0);
            ctx.lineTo(20 + bulletRange, 0);
            ctx.stroke();
            ctx.restore();
        }

        // Function to draw asteroids
        function drawAsteroids() {
            asteroids.forEach(asteroid => {
                ctx.save();
                ctx.translate(asteroid.x, asteroid.y);
                ctx.rotate(asteroid.angle || 0); // Optional: Add rotation if desired

                // **Change color based on if the fact is missed**
                const isMissed = missedFacts.some(fact => fact.a === asteroid.a && fact.b === asteroid.b);
                ctx.strokeStyle = isMissed ? 'orange' : 'white'; // Orange for missed facts
                ctx.fillStyle = isMissed ? 'yellow' : 'lightgray'; // Yellow fill for missed facts

                ctx.beginPath();
                asteroid.vertices.forEach((vertex, index) => {
                    const x = vertex.distance * Math.cos(vertex.angle);
                    const y = vertex.distance * Math.sin(vertex.angle);
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                // Draw multiplication fact at center
                ctx.fillStyle = 'black';
                ctx.font = `${Math.max(14, asteroid.size / 2)}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(`${asteroid.a} x ${asteroid.b}`, 0, 0);

                ctx.restore();
            });
        }

        // Function to draw bullets
        function drawBullets() {
            bullets.forEach(bullet => {
                ctx.beginPath();
                ctx.arc(bullet.x, bullet.y, 3, 0, Math.PI * 2);
                ctx.fillStyle = 'yellow';
                ctx.fill();
            });
        }

        // Function to fire a bullet
        function fireBullet() {
            if (currentAnswer === '') return; // Do not fire if no answer is entered
            const bullet = {
                x: ship.x + Math.cos(ship.angle) * 20,
                y: ship.y + Math.sin(ship.angle) * 20,
                dx: Math.cos(ship.angle) * bulletSpeed,
                dy: Math.sin(ship.angle) * bulletSpeed,
                distanceTraveled: 0
            };
            bullets.push(bullet);
        }

        // Function to update ship position and rotation
        function updateShip() {
            if (keys['ArrowLeft']) {
                ship.angle -= 0.05;
            }
            if (keys['ArrowRight']) {
                ship.angle += 0.05;
            }
            if (keys['ArrowUp']) {
                ship.velocity.x += Math.cos(ship.angle) * ship.speed;
                ship.velocity.y += Math.sin(ship.angle) * ship.speed;
            }

            // Apply friction to slow down the ship gradually
            ship.velocity.x *= 0.99;
            ship.velocity.y *= 0.99;

            ship.x += ship.velocity.x;
            ship.y += ship.velocity.y;

            // Wrap around screen edges
            if (ship.x < 0) ship.x = canvas.width;
            if (ship.x > canvas.width) ship.x = 0;
            if (ship.y < 0) ship.y = canvas.height;
            if (ship.y > canvas.height) ship.y = 0;
        }

        // Function to update asteroids' positions
        function updateAsteroids() {
            asteroids.forEach(asteroid => {
                asteroid.x += asteroid.velocity.x;
                asteroid.y += asteroid.velocity.y;

                // Wrap around screen edges
                if (asteroid.x < -asteroid.size) asteroid.x = canvas.width + asteroid.size;
                if (asteroid.x > canvas.width + asteroid.size) asteroid.x = -asteroid.size;
                if (asteroid.y < -asteroid.size) asteroid.y = canvas.height + asteroid.size;
                if (asteroid.y > canvas.height + asteroid.size) asteroid.y = -asteroid.size;
            });

            // Check if all asteroids are cleared
            if (asteroids.length === 0) {
                score += 500; // Add 500 bonus points
                scoreElement.textContent = `Score: ${score}`;
                initAsteroids(); // Restart the game by creating new asteroids
            }
        }

        // Function to update bullets
        function updateBullets() {
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];
                bullet.x += bullet.dx;
                bullet.y += bullet.dy;
                bullet.distanceTraveled += bulletSpeed;

                // Remove bullet if it exceeds its range
                if (bullet.distanceTraveled > bulletRange) {
                    bullets.splice(i, 1);
                    continue;
                }

                // Check collision with asteroids
                for (let j = asteroids.length - 1; j >= 0; j--) {
                    const asteroid = asteroids[j];
                    const dist = Math.hypot(bullet.x - asteroid.x, bullet.y - asteroid.y);
                    if (dist < asteroid.size) {
                        // **Correct Answer Handling**
                        if (parseInt(currentAnswer) === (asteroid.a * asteroid.b)) {
                            score += asteroid.a * asteroid.b;
                            scoreElement.textContent = `Score: ${score}`;

                            // Split asteroid if size is large enough
                            if (asteroid.size > minAsteroidSize + 10) {
                                const newSize = asteroid.size / 2;
                                for (let k = 0; k < 2; k++) {
                                    const newAsteroid = createAsteroid(asteroid.x, asteroid.y, newSize);
                                    // Add outward velocity
                                    newAsteroid.velocity.x += Math.cos(ship.angle) * 1;
                                    newAsteroid.velocity.y += Math.sin(ship.angle) * 1;
                                    newAsteroid.size = newSize;
                                    newAsteroid.vertices = generateAsteroidVertices(newSize);
                                    asteroids.push(newAsteroid);
                                }
                            }

                            asteroids.splice(j, 1); // Remove the destroyed asteroid
                            bullets.splice(i, 1); // Remove the bullet
                            currentAnswer = ''; // Reset entered answer
                            updateCurrentAnswerDisplay();
                            break; // Exit the asteroid loop
                        } else {
                            // **Incorrect Answer Handling**
                            // Clear the currentAnswer buffer
                            currentAnswer = '';
                            updateCurrentAnswerDisplay();

                            // **Triplicate Exposure Logic**
                            addMissedFact(asteroid.a, asteroid.b);

                            // Optionally, provide feedback to the player
                            // For example, flash the asteroid or display a message
                            displayIncorrectFeedback();

                            bullets.splice(i, 1); // Remove the bullet
                            break; // Exit the asteroid loop since bullet has hit
                        }
                    }
                }
            }
        }

        // **Function to Add Missed Facts**
        function addMissedFact(a, b) {
            // Check if the fact already exists in missedFacts
            const existingFact = missedFacts.find(fact => fact.a === a && fact.b === b);
            if (existingFact) {
                // Increment timesMissed to increase exposure if needed
                existingFact.timesMissed += 1;
            } else {
                // Add new missed fact with timesMissed initialized
                missedFacts.push({ a, b, timesMissed: 1 });
            }

            // **Adjust the exposure multiplier based on timesMissed**
            // This ensures that each missed fact is tripled in exposure
            // You can modify this logic as needed
            localStorage.setItem('missedFacts', JSON.stringify(missedFacts));
        }

        // **Function to Display Incorrect Answer Feedback**
        function displayIncorrectFeedback() {
            const feedbackElement = document.getElementById('feedback');
            feedbackElement.textContent = 'Wrong Answer!';
            feedbackElement.style.display = 'block';
            feedbackElement.classList.add('fade-out');

            // Remove the feedback after the animation completes
            feedbackElement.addEventListener('animationend', () => {
                feedbackElement.style.display = 'none';
                feedbackElement.classList.remove('fade-out');
            }, { once: true });
        }

        // Function to check collision between ship and asteroids
        function checkShipCollision() {
            for (let asteroid of asteroids) {
                const dist = Math.hypot(ship.x - asteroid.x, ship.y - asteroid.y);
                if (dist < asteroid.size + 10) { // 10 is approximate ship radius
                    endGame();
                    break;
                }
            }
        }

        // Function to end the game
        function endGame() {
            gameOver = true;
            gameOverElement.style.display = 'flex';
            finalScoreElement.textContent = `Your Score: ${score}`;
            
            // Check if current score is a high score
            const lowestHighScore = highScores.length < maxHighScores ? 0 : highScores[highScores.length - 1].score;
            if (score > lowestHighScore) {
                // Prompt for player name
                let playerName = prompt('New High Score! Enter your name:');
                if (playerName === null || playerName.trim() === '') {
                    playerName = 'Anonymous';
                }
                
                // Create new high score entry
                const newHighScore = { name: playerName, score: score };
                
                // Add new high score and sort the list
                highScores.push(newHighScore);
                highScores.sort((a, b) => b.score - a.score);
                
                // Keep only top maxHighScores
                highScores = highScores.slice(0, maxHighScores);
                
                // Save updated high scores to localStorage
                localStorage.setItem('highScores', JSON.stringify(highScores));
            }
            
            // Update high score display
            displayHighScores();

            // Optionally, reset missedFacts or keep them persisted
            // Uncomment the next line to reset after each game
            // missedFacts = [];

            // Save the missedFacts to localStorage
            localStorage.setItem('missedFacts', JSON.stringify(missedFacts));
        }

        // Function to display high scores
        function displayHighScores() {
            if (highScores.length === 0) {
                highScoreElement.innerHTML = '<h2>High Scores</h2><p>No high scores yet!</p>';
                return;
            }

            let highScoresHTML = `<h2>High Scores</h2><ol>`;
            highScores.forEach(scoreEntry => {
                if (scoreEntry.name && scoreEntry.score !== undefined) {
                    highScoresHTML += `<li>${scoreEntry.name}: ${scoreEntry.score}</li>`;
                }
            });
            highScoresHTML += `</ol>`;
            
            // Insert into the highScoreElement
            highScoreElement.innerHTML = highScoresHTML;
        }

        function startGame() {
            gameStarted = true;
            gameOver = false;
            score = 0;
            currentAnswer = '';
            bullets.length = 0;
            asteroids.length = 0;
            initAsteroids();
            startScreen.style.display = 'none';
            gameOverElement.style.display = 'none';
            scoreElement.textContent = 'Score: 0';
            gameLoop();
        }

        function gameLoop() {
            if (!gameStarted) return;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            updateShip();
            updateAsteroids();
            updateBullets();
            checkShipCollision();

            drawShip();
            drawAsteroids();
            drawBullets();

            if (!gameOver) {
                requestAnimationFrame(gameLoop);
            } else {
                displayGameOver();
            }
        }

        function displayGameOver() {
            gameOverElement.style.display = 'flex';
        }

        // Event listener for the start button
        startButton.addEventListener('click', startGame);

        // Event listener for the play again button
        playAgainButton.addEventListener('click', startGame);

        // Initial setup
        function init() {
            drawInitialScene();
            startScreen.style.display = 'flex';
            
            // Optionally display high scores on the start screen
            displayStartScreenHighScores();
        }

        function drawInitialScene() {
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            // You can add some static asteroids or other decorative elements here if you want
        }

        // Function to display high scores on the start screen
        function displayStartScreenHighScores() {
            if (highScores.length === 0) {
                return; // Do not display anything if there are no high scores
            }

            let highScoresHTML = `<h2>High Scores</h2><ol>`;
            highScores.forEach(scoreEntry => {
                if (scoreEntry.name && scoreEntry.score !== undefined) {
                    highScoresHTML += `<li>${scoreEntry.name}: ${scoreEntry.score}</li>`;
                }
            });
            highScoresHTML += `</ol>`;
            
            // Create a new element or append to an existing one
            const highScoresContainer = document.createElement('div');
            highScoresContainer.innerHTML = highScoresHTML;
            startScreen.appendChild(highScoresContainer);
        }

        // Call init to set up the initial state
        init();
    </script>
</body>
</html>
